#include<iostream>
#include<vector>
#include<utility>
#include<string>
#include<boost/regex.hpp>
//kompilowane w g++ z opcjami -Wall -O2 -std=c++11 -lboost_regex

using namespace std;

vector<pair<string, int>> historia; 
//to warto by wrzucic do przetworz_wejscie() chyba i przekazywac innym metodom jako parametr przez referencje/wskaznik

void wypisz_liste(int rok1, int rok2); // TODO
// ta procedurka powinna wypisywac juz koncowa liste (sortowac historie odpowiednio i odpowiednio wypisywac)
// pamietaj o uzyciu juz wbudowanych algorytmow sortujacych czesciowo :) gdzies na pewno sa opisane, sa czescia #include<algorithm> chyba

void wypisz_wszystko() { // procedurka tylko do debugowania
	for(unsigned int i=0; i < historia.size(); i++) {
		cout << historia[i].first << " " << historia[i].second << endl;
	}
}

pair<string, int> stworzMonete(string opis, int rok) {
	pair<string, int> moneta(opis, rok);
	return moneta;
}

void wypisz_blad(long wiersz, string tresc_linijki) {
	cerr << "Error in line " << wiersz << ": " << tresc_linijki << endl;
}

void przetworz_wejscie() {
	long wiersz = 1;
	bool koniec = false;
	string wejscie;
	boost::regex wzorzec_monety("(\\S.*\\S)(\\s+)(-?\\d+)(\\s*)");
	boost::regex wzorzec_koncowy("(\\d+)(\\s+)(\\d+)");
	boost::smatch wynik;
	int rok1, rok2;
	while(getline(cin, wejscie)) {
		if (koniec) {
			wypisz_blad(wiersz, wejscie)
		} else 
			if (regex_match(wejscie, wynik, wzorzec_koncowy)) {
				rok1 = stoi(wynik[1]);
				rok2 = stoi(wynik[3]);
				if (rok1 != 0 && rok2 != 0) {
					if (rok1 >= rok2) {
						//zgodnie ze specyfikacja taki wiersz jest bledem,
						//ALE rowniez jest tez wierszem koncowym i wypisujemy wszystko
						wypisz_blad(wiersz, wejscie); 
					}
					koniec = true;
					wypisz_wszystko();
					//wypisz_liste(rok1, rok2);
				} else {
					//wiersz z chocby jednym zerem jest bledny
					//i nie traktujemy go jako konca wejscia
					wypisz_blad(wiersz, wejscie);
				}
			} else {
				if (regex_match(wejscie, wynik, wzorzec_monety)) { //jesli linijka jest poprawnie sformatowana, dorzucamy nowa monete
					historia.push_back(stworzMonete(wynik[1], stoi(wynik[3])));
				} else {
					wypisz_blad(wiersz, wejscie);
				}
			}
		}
		wiersz++;
	}
}

int main() {
	przetworz_wejscie();
}

